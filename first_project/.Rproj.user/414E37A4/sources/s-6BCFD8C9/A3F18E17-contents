# 백터의 생성
a <- c(3,2,1)

# 백터값 확인
a

# 백터의 정보 확인
str(a)

# 백터의 길이
length(a)

# 논리형 백터
lgl_v <- c(T, F, TRUE, FALSE)
lgl_v

typeof(lgl_v)

# 숫자형 백터
# double 은 실수형
typeof(1)

# integer는 정수형
typeof(1L)

num_v <- c(10, -100, 0.6, 0.333)
num_v
typeof(num_v)

# nan은 not a number 의 약자로 표현이 불가능한 연산에 대한 답으로 사용
# sqrt() 함수는 루트 연산을 수행
sqrt(-4)

# na는 Not Available의 약자로 결측된 값, 혹은 사용할 수 없음을 뜻함
c(10.0, 0/0, NA)
0/0 == NaN
is.nan(0/0)
is.na(0/0)

# 글자형 백터
# 글자형은 따옴표나 쌍따옴표로 감싸서 표현

chr_v <- c("글자형", "a", "T", "1")
typeof(chr_v)

"따옴표를 글자로 인식하려면 ' 쌍따옴표로 감싼다."
'쌍따옴표를 글자로 인식하려면 " 따옴표로 감싼다.'
"같은 것으로 처리하고 싶을 때는 \" 같이 표시한다."

# 단일 종류의 데이터 다루기
# 강제로 다른 종류의 데이터로 바꾸기
# 강제형변환 이라는 용어를 사용함
# 논리형 > 숫자형 > 글자형 방향으로 바꿔준다
tem <- c(1, T, F, TRUE)
tem
typeof(tem)

tem <- c("글자", 1, -1)
tem
typeof(tem)

tem <- c("글자", T, F)
tem
typeof(tem)

## 강제로 데이터의 길이 맞추기
# 스칼라란 1개의 데이터를 뜻함
# 벡터는 스칼라를 포함함
# 데이터가 여러 개인 데이터와 하나의 데이터를 연산하면 ?

# 1 ~ 10 까지의 백터를 만듬
1:10
# 각각의 요소에 + 10 을 한 백터를 만듬
1:10 + 10
# 10 ~ 3 까지의 백터를 만듬
10:3

# 데이터의 길이가 다른 데이터들을 연산하면?
# 재활용 규칙이라고 함
1:10 + 1:5

# 길이가 맞지 않지만 결과물은 줌. 경고문과 비슷한 문구가 나옴
1:10 + 1:3


## 백터내의 데이터에 이름 지정하기
# key-value 라고 부르며 여기서 key가 이름, value가 데이터를 뜻함
# R에서 모든 벡터는 key-value로 데이터의 이름을 지정할 수 있음
# key = value 의 형식을 따르며 key는 이름이기 때문에 따옴표를 생략할 수 있음
# 이름은 데이터의 일부를 사용하고 싶을 때 유용함

c("a" = "k")
c(a = "k", b = "kk", c = "kkk")

## 데이터의 일부를 사용하기
# 서브넷이라고 부르며 가지고 있는 데이터에서 일부만을 사용할 때의 문법을 뜻함
# 백터는 백터[]의 형태로 뒤에 대괄호를 붙이며 대괄호 안에 백터를 넣어서 일부의 데이터만 사용
subs <- c("하나", "둘", "셋", "넷", "다섯")
subs
subs[]

## 논리형 벡터로 데이터의 일부 사용
# 데이터의 갯수에 맞게 논리형 데이터를 넣어야 하며, 부족하게 입력하면 재활용 규칙이 많이 입력하면 NA를 붙여서 결과를 줌
subs[c(T,F,T,F,T)]

# 재사용규칙
subs[c(T,F)]

subs[c(T,F,T,F,T,T,T)]